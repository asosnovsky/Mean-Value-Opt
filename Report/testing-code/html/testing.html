
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Testing and Code</title><meta name="generator" content="MATLAB 8.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-12-03"><meta name="DC.source" content="testing.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Testing and Code</h1><!--introduction--><p>For testing of our code we looked at how well our functions performed relative to the native matlab functions. For the selection algorithm we only used matlab as a benchmark, as there is no exisiting function that parrellels. Please note that all the tests found here can be found in the <tt>Mean-Value-Opt/implementation/data_matlabazer.m</tt> file.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Data</a></li><li><a href="#3">Lagrange, Variance minimization method</a></li><li><a href="#5">Test Sharpe Optimization</a></li></ul></div><h2>Data<a name="1"></a></h2><p>We start by taking a random portion of data within our dataset, as follows:</p><pre class="language-matlab">[ Ret, CoRisk, stockNames, selData, data  ] = data_selector( folders, dates(1), sectors(6) );
</pre><p>Note that <tt>sectors(6)</tt> is arbitrary sector name chosen from our sectors list, and <tt>dates(1)</tt>, is simply the data from <tt>2008-2009</tt>. This function will take the data from the folder, filter it, and then store it in the <tt>selData</tt> variable. Then it will compute the returns, and covariance and store them in the <tt>Ret</tt> and <tt>CoRisk</tt> variables respectively. The variable <tt>data</tt> is simply the unfiltered dataset.</p><h2>Lagrange, Variance minimization method<a name="3"></a></h2><p><b>Overview</b>:</p><p>Building on the mathematical theory we take the covariance matrix and the returns matrix and constructs the following matrices: Note that to ensure that the program does not run for too long, we control the number of assets we wish to test. If we wanted to test <b>all</b> of the assets we would set <tt>n = length(Ret)</tt>.</p><pre class="language-matlab">n   = 100;
M   = Ret(1:n);
S   = 2.*CoRisk(1:n,1:n);
mp  = 0.05;
</pre><pre class="language-matlab">A = [ S M' ones(n,1); M 0 0 ; ones(1,n) 0 0 ];
x = [ zeros(n,1); mp; 1 ];
</pre><p>Hence, we can obtain the solution for our wieghts as follows: <tt>Weights = A\x</tt>;</p><p><b>Testing</b>:</p><p>Next we will see how our function compares to the matlab base function <tt>quadprog</tt>. This will surve us as a benchmark for our function. The folllowing code will compare the matlab function to us.</p><pre class="codeinput">mp  = 0.05;
n   = length(Ret);
S   = CoRisk(1:n,1:n);
M   = Ret(1:n);

<span class="comment">% Matlab</span>
tic
    w = quadprog(2.*S,[],[],[],[ M ; ones(1,n)],[mp;1],<span class="keyword">...</span>
            [],[],[],<span class="keyword">...</span>
            optimoptions(<span class="string">'quadprog'</span>,<span class="string">'Algorithm'</span>,<span class="string">'interior-point-convex'</span>,<span class="string">'Display'</span>,<span class="string">'off'</span>));
    fprintf(<span class="string">'Matlab Time:  '</span>);
toc

<span class="comment">% Us</span>
tic
    WW = [ 2*S M' ones(n,1); M 0 0 ; ones(1,n) 0 0 ]\[ zeros(n,1); mp; 1 ];
    fprintf(<span class="string">'\nUs Time:  '</span>);
toc

<span class="comment">% Comparison</span>
square_root_sum_of_error_squared = sqrt(sum((WW(1:end-2)-w).^2)./n)
</pre><pre class="codeoutput">Matlab Time:  Elapsed time is 0.030577 seconds.

Us Time:  Elapsed time is 0.000972 seconds.

square_root_sum_of_error_squared =

   1.2973e-13

</pre><p>As you can see, our function outperformed the matlab function in terms of time. This is due to the fact that the matlab function runs several tests on the matrices before actually computing the weights.</p><h2>Test Sharpe Optimization<a name="5"></a></h2><p>The sharpe optimization procudure we wrote, makes use of the bisection method for finding the sharpe ratio. It is stored in the <tt>optimizeSupreme</tt> function. For more detail, please refer to the math-section of this paper. The matlab function we chose as the benchmark is the <tt>estimateMaxSharpeRatio</tt> which is a part of the <tt>Portfolio Optimization and Asset Allocation</tt> package in matab.</p><p>We run our comparison code as follows:</p><pre class="codeinput">clear <span class="string">n</span> <span class="string">M</span> <span class="string">S</span> <span class="string">rfr</span> <span class="string">WMp</span> <span class="string">mLims</span>
clc
n       = 10;
tP      = 1:n;
M       = Ret(tP);
S       = CoRisk(tP,tP);
rfr     = RFR(1);
mLims   = 1E10;

<span class="comment">% Matlab</span>
tic
    p =  Portfolio(<span class="string">'AssetMean'</span>,M,<span class="string">'AssetCovar'</span>,S,<span class="string">'RiskFreeRate'</span>,rfr,<span class="string">'Budget'</span>,1,<span class="string">'LowerBound'</span>,-mLims,<span class="string">'UpperBound'</span>,mLims);
    WMp = estimateMaxSharpeRatio(p);
    Matlab_Sharpe = (M*WMp-rfr)/sqrt(WMp'*S*WMp)
    fprintf(<span class="string">'Matlab Time:  '</span>);
toc
<span class="comment">% Us</span>
tic
    [ sharpe, Wp, ~, ~ ] = optimizeSupreme( M, S, rfr );
    Our_Sharpe = (M*Wp-rfr)/sqrt(Wp'*S*Wp)
    fprintf(<span class="string">'\nUs Time:  '</span>);
toc
</pre><pre class="codeoutput">
Matlab_Sharpe =

    0.0963

Matlab Time:  Elapsed time is 0.892123 seconds.
</pre><pre class="codeoutput error">Undefined function 'optimizeSupreme' for input arguments of type 'double'.

Error in testing (line 91)
    [ sharpe, Wp, ~, ~ ] = optimizeSupreme( M, S, rfr );
</pre><p>As you can see, our function outperformed the matlab function by a great deal. As a matter of fact, it performs significally better with higher values of <tt>n</tt>. However, our sharpe value seems to be at first glance much lower than matlab. This is beacuse we found a <i>parrellel</i> portfolio to the one of matlab. To show what we mean by that, one may simply observe the ratio between the matlab weights and our weights:</p><pre class="codeinput">disp(WMp./Wp);
</pre><p>Or may look at the plot of the optimization period:</p><pre class="codeinput">figure(<span class="string">'Name'</span>,<span class="string">'Our Optimization'</span>);
plot(Wp'*selData(:,1:n)')
title(<span class="string">'Our Function'</span>);
xlabel(<span class="string">'Time'</span>);
ylabel(<span class="string">'Value of Portfolio'</span>);
figure(<span class="string">'Name'</span>,<span class="string">'Matlab Optimization'</span>);
plot(WMp'*selData(:,1:n)')
title(<span class="string">'Matlab'</span>);
xlabel(<span class="string">'Time'</span>);
ylabel(<span class="string">'Value of Portfolio'</span>);
</pre><p>As you can see the only difference between our method and the matlab method is a multiplier. In this case the multiplier can be computed as approximately:</p><pre class="codeinput">approximate_multiplier = mean(WMp./Wp)
WWW = approximate_multiplier.*Wp;
Our_Adjusted_Sharpe = (M*WWW-rfr)/sqrt(WWW'*S*WWW)
</pre><p>Hence, our method compares well with matlab. As it provides us a good-enough estimate for the sharpe of the portfolio.</p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Testing and Code
% For testing of our code we looked at how well our functions performed relative to the native matlab functions. For the selection algorithm we only used matlab as a benchmark, as there is no exisiting function that parrellels. Please note that all the tests found here can be found in the |Mean-Value-Opt/implementation/data_matlabazer.m| file.
% 
%% Data
% We start by taking a random portion of data within our dataset, as follows:
%%
% 
%   [ Ret, CoRisk, stockNames, selData, data  ] = data_selector( folders, dates(1), sectors(6) );
% 
% Note that |sectors(6)| is arbitrary sector name chosen from our sectors list, and |dates(1)|, is simply the data from |2008-2009|. This function will take the data from the folder, filter it, and then store it in the |selData| variable. 
% Then it will compute the returns, and covariance and store them in the |Ret| and |CoRisk| variables respectively. The variable |data| is simply the unfiltered dataset.
%

%% Lagrange, Variance minimization method
%
% *Overview*:
%
% Building on the mathematical theory we take the covariance matrix and the returns matrix and constructs the following matrices:
% Note that to ensure that the program does not run for too long, we
% control the number of assets we wish to test. If we wanted to test *all*
% of the assets we would set |n = length(Ret)|.
%
%   n   = 100;
%   M   = Ret(1:n);
%   S   = 2.*CoRisk(1:n,1:n);
%   mp  = 0.05; 
%
%   A = [ S M' ones(n,1); M 0 0 ; ones(1,n) 0 0 ];
%   x = [ zeros(n,1); mp; 1 ];
%  
% Hence, we can obtain the solution for our wieghts as follows: |Weights = A\x|;
%
% *Testing*:
%
% Next we will see how our function compares to the matlab base function
% |quadprog|. This will surve us as a benchmark for our function. The
% folllowing code will compare the matlab function to us.
mp  = 0.05;
n   = length(Ret);
S   = CoRisk(1:n,1:n);
M   = Ret(1:n);

% Matlab
tic
    w = quadprog(2.*S,[],[],[],[ M ; ones(1,n)],[mp;1],...
            [],[],[],...
            optimoptions('quadprog','Algorithm','interior-point-convex','Display','off'));
    fprintf('Matlab Time:  ');
toc

% Us
tic
    WW = [ 2*S M' ones(n,1); M 0 0 ; ones(1,n) 0 0 ]\[ zeros(n,1); mp; 1 ];
    fprintf('\nUs Time:  ');
toc

% Comparison
square_root_sum_of_error_squared = sqrt(sum((WW(1:end-2)-w).^2)./n)
%%
% As you can see, our function outperformed the matlab function in terms of
% time. This is due to the fact that the matlab function runs several tests
% on the matrices before actually computing the weights.
%
%% Test Sharpe Optimization
% The sharpe optimization procudure we wrote, makes use of the
% bisection method for finding the sharpe ratio. It is stored in the
% |optimizeSupreme| function. For more detail, please refer to the
% math-section of this paper. The matlab function we chose as the benchmark
% is the |estimateMaxSharpeRatio| which is a part of the |Portfolio
% Optimization and Asset Allocation| package in matab.
%
% We run our comparison code as follows:
clear n M S rfr WMp mLims
clc
n       = 10;
tP      = 1:n;
M       = Ret(tP);
S       = CoRisk(tP,tP);
rfr     = RFR(1);
mLims   = 1E10;

% Matlab
tic
    p =  Portfolio('AssetMean',M,'AssetCovar',S,'RiskFreeRate',rfr,'Budget',1,'LowerBound',-mLims,'UpperBound',mLims);
    WMp = estimateMaxSharpeRatio(p);
    Matlab_Sharpe = (M*WMp-rfr)/sqrt(WMp'*S*WMp)
    fprintf('Matlab Time:  ');
toc 
% Us
tic
    [ sharpe, Wp, ~, ~ ] = optimizeSupreme( M, S, rfr );
    Our_Sharpe = (M*Wp-rfr)/sqrt(Wp'*S*Wp)
    fprintf('\nUs Time:  ');
toc
%%
% As you can see, our function outperformed the matlab function by a great
% deal. As a matter of fact, it performs significally better with higher
% values of |n|. However, our sharpe value seems to be at first glance much
% lower than matlab. This is beacuse we found a _parrellel_ portfolio to
% the one of matlab. To show what we mean by that, one may simply observe
% the ratio between the matlab weights and our weights:
disp(WMp./Wp);
%%
% Or may look at the plot of the optimization period:
figure('Name','Our Optimization');
plot(Wp'*selData(:,1:n)')
title('Our Function');
xlabel('Time');
ylabel('Value of Portfolio');
figure('Name','Matlab Optimization');
plot(WMp'*selData(:,1:n)')
title('Matlab');
xlabel('Time');
ylabel('Value of Portfolio');
%%
% As you can see the only difference between our method and the matlab
% method is a multiplier. In this case the multiplier can be computed as
% approximately:
approximate_multiplier = mean(WMp./Wp)
WWW = approximate_multiplier.*Wp;
Our_Adjusted_Sharpe = (M*WWW-rfr)/sqrt(WWW'*S*WWW)
%%
% Hence, our method compares well with matlab. As it provides us a
% good-enough estimate for the sharpe of the portfolio.

##### SOURCE END #####
--></body></html>